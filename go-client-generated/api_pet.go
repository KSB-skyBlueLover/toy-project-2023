/*
 * Swagger Petstore - OpenAPI 3.0
 *
 * This is a sample Pet Store Server based on the
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context" // https://dev-yakuza.posstree.com/ko/golang/context/
	// Golang에서 컨텍스트(Context)는 작업 명세서와 같은 역할로, 작업 가능한 시간, 작업 취소 등 작업의 흐름을 제어하는데 사용
	// Golang에서는 다음과 같이 context 패키지를 사용하여 컨텍스트를 정의
	// import "context"
	// // Cancel
	// ctx, cancel := context.WithCancel(context.Background())
	// // Deadline
	// ctx, cancel := context.WithDeadline(context.Background(), TIME)
	// // Timeout
	// ctx, cancel := context.WithTimeout(context.Background(), DURATION)
	// WithCancel
	// 컨텍스트가 cancel 혹은 timeout으로 종료되면 컨텍스트의 Done이 호출.

	"io/ioutil" // https://thebook.io/006806/ch07/03/03_01/
	//io/ioutil 패키지는 파일 입출력과 관련된 유틸리티성 라이브러리로 다음과 같은 기능을 제공한다.

	"net/http" // https://strange-developer.tistory.com/49
	//net/http 패키지는 HTTP 클라이언트와 서버를 작성하는 데 필요한 모든 기능을 제공한다.

	"net/url" // https://minwook-shin.github.io/learn-go-url/
	//웹 애플리케이션을 만들다 보면 URL 문자열을 조작해야 하는 경우가 많다. Go net/url 패키지로 URL을 조작할 수 있다.
	//url 파싱등

	//url.Parse 메서드로 URL을 파싱할 수 있다. 파싱하고 나면 url.URL 구조체를 반환한다. 주요한 메서드와 값들을 정리했다.
	// URL.Scheme : URL 스키마.
	// URL.User : 유저 이름과 유저 패스워드.
	// URL.Host : 호스트이름과 포트번호를 포함한 문자열을 반환한다. 형식은 "host:port"다. strings.Split메서드로 host와 port를 가져올 수 있는데, net.SplitHostPort메서드를 이용하는게 더 편하다.
	// URL.Path : 패스. 보통 호스트내에서 자원의 위치를 기술하기 위해서 사용한다.
	// URL.Fragment : # 뒤에 있는 값
	// URL.RawQuery : ?뒤에 있는 key=value 스타일의 값이다.
	// URL.RawQuery는 key=value 스타일로 돼 있다. url.ParseQuery메서드로 RawQuery를 map으로 만들어서 사용 할 수 있다.

	"strings" // https://pyrasis.com/book/GoForTheReallyImpatient/Unit46/02
	//문자열 처리 관련 기능 제공
)

// Linger please
var (
	_ context.Context
)

type PetApiService service
//petapiservice 라는 타입을 선언했는데 이건 service 객체이다
//service 객체는 client.go의 service이지
//client.go의 service는 apiclient 객체를 가지고 있고,
//api client는 configuration, service, petapiservice 를 가지지
//최초 한번만 생성하도록 구성



/*	
PetApiService Update an existing pet
Update an existing pet by Id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Update an existent pet in the store
@return Pet
*/

// context parameter 는 인증, 로깅, cancel, deadline 등을 위한 parameter.
// http.request 나 context.background 로 생성된 컨텍스트를 넘겨서 사용함.


func (a *PetApiService) UpdatePet(ctx context.Context, body Pet) (Pet, *http.Response, error) { //pet api 수정 메서드
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Pet
	) 
	//============= PetApiService 메서드 구현 (Pointer Receiver로 구현하여 데이터 변경 즉시 반영)
	


	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/pet"
	
	//a.client.cfg.basepath = https://petstore3.swagger.io/api/v3
	//localvarpath = https://petstore3.swagger.io/api/v3/pet

	localVarHeaderParams := make(map[string]string) // header는 map
	localVarQueryParams := url.Values{} // query parameter 은 url 파싱을 통해 (net/url) 받음
	localVarFormParams := url.Values{} // form parameter 는 url 파싱을 통해 받음

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}
	//content type 을 담을 header.. 근데 왜 배열? json/xml/ 기타등등이 될 수 있으니까

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// 헤더 content type을 쟤네중에 하나를 고름. 비어있는게 아니라면 
	// localvarheadrparams에 contenttype을 골라낸 컨텐트 타입으로 설정
	// json 우선순위로 리턴하는데.. 이해가 안된다





	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}
	// 반환받는 헤더 설정. 가능한 리스트들은 두개다
	// response에 있는 헤더네


	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts) // 마찬가지로 json 우선순위로 반환 없으면 , 로 join해서 
																			  // 나머지 header 합쳐서 반환. 왜 합치는지 이해가 안됨
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	//반환 헤더가 공백이 아니라면 localvarheaderparams에 accept를 그거로 설정


	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(
		ctx, localVarPath, localVarHttpMethod, localVarPostBody,
		 localVarHeaderParams, localVarQueryParams, 
		 localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	//r은 *http.Request 타입이다. localVarRequest *http.Request 
	//net/http 모듈 사용해서 new request도 만든다..


	//===============================================================================================


	localVarHttpResponse, err := a.client.callAPI(r)  


		//client 는 client.go 의 api client 객체에 해당하네
		//그럼 a는 client의 service 객체에 해당하겠네!!


														//request *http.Request 객체 받아서 net/http의 do method로 http request를 보냄
														//do는 http request 객체 받아서 http response 반환하는 net/http method
														//그래서 localvarHttpResponse를 반환받지 callAPI를 하고나서..	
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}//반환값 자체를 받지 못하거나 에러 발생한 경우

	
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	//정상인 경우 localVarHttpResponse (http response 객체)의 body를 ioutil.ReadAll로 localVarBody에([]bytes) 읽어들인다.
	//즉, response body를 읽음
	//그 후 body를 close 시키고 에러가 있다면 반환
	//여기서는 받은 반환값을 ioutil로 읽지 못하는 경우에 대한 에러처리임




	//============================================================

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		//localVarBody(json) => localVarReturnValue(Pet)
		//decode에 참조 형식으로 localVarReturnValue를 넘겨줌 (decode는 interface{} 를 매개변수로 받아 모든 타입에 대해 허용
								//하므로 xml, json모두 가능한 것)
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}//디코딩까지 성공적으로 수행한 경우 파싱결과(localVarReturnValue(Pet 구조체) 와 localVarHttpResponse(http Response)) 반환
		
	}//성공 케이스
	//http response



	//localVarBody : http response의 body
	//localvarhttpresponse.status : status
	//// If we succeed, return the data, otherwise pass on to decode error.
	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		if localVarHttpResponse.StatusCode == 200 {/// ? 300 if문에 들어왔는데 200인지 왜 체크하는거지
			var v Pet
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
			//localVarBody([]bytes) => v(Pet) 파싱
			//decode가 byetes배열의 body를 파싱해서 v에 파싱된 pet 객체를 담아줌
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}//파싱 실패시 newErr 객체에 error 담아서 반환


				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
				//파싱 성공시 newErr 객체의 model에 decoding된 localVarBody 객체 담아서 반환 - localVarBody는 300(에러) response의 body에 해당
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
